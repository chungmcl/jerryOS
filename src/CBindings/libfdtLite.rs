/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const NULL: u32 = 0;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const SY: &[u8; 3] = b"sy\0";
pub const ST: &[u8; 3] = b"st\0";
pub const LD: &[u8; 3] = b"ld\0";
pub const MEM_PAGE_GRANULARITY: u32 = 14;
pub const MEM_PAGE_LEN: u32 = 16384;
pub const FDT_MAGIC: u32 = 3490578157;
pub const FDT_BEGIN_NODE: u32 = 1;
pub const FDT_END_NODE: u32 = 2;
pub const FDT_PROP: u32 = 3;
pub const FDT_NOP: u32 = 4;
pub const FDT_END: u32 = 9;
pub const FDT_FIRST_SUPPORTED_VERSION: u32 = 2;
pub const FDT_LAST_COMPATIBLE_VERSION: u32 = 16;
pub const FDT_LAST_SUPPORTED_VERSION: u32 = 17;
pub const FDT_ERR_NOTFOUND: u32 = 1;
pub const FDT_ERR_EXISTS: u32 = 2;
pub const FDT_ERR_NOSPACE: u32 = 3;
pub const FDT_ERR_BADOFFSET: u32 = 4;
pub const FDT_ERR_BADPATH: u32 = 5;
pub const FDT_ERR_BADPHANDLE: u32 = 6;
pub const FDT_ERR_BADSTATE: u32 = 7;
pub const FDT_ERR_TRUNCATED: u32 = 8;
pub const FDT_ERR_BADMAGIC: u32 = 9;
pub const FDT_ERR_BADVERSION: u32 = 10;
pub const FDT_ERR_BADSTRUCTURE: u32 = 11;
pub const FDT_ERR_BADLAYOUT: u32 = 12;
pub const FDT_ERR_INTERNAL: u32 = 13;
pub const FDT_ERR_BADNCELLS: u32 = 14;
pub const FDT_ERR_BADVALUE: u32 = 15;
pub const FDT_ERR_BADOVERLAY: u32 = 16;
pub const FDT_ERR_NOPHANDLES: u32 = 17;
pub const FDT_ERR_BADFLAGS: u32 = 18;
pub const FDT_ERR_ALIGNMENT: u32 = 19;
pub const FDT_ERR_MAX: u32 = 19;
pub const FDT_MAX_PHANDLE: u32 = 4294967294;
pub const FDT_MAX_NCELLS: u32 = 4;
pub const FDT_CREATE_FLAG_NO_NAME_DEDUP: u32 = 1;
pub const FDT_CREATE_FLAGS_ALL: u32 = 1;
pub const FDT_SW_MAGIC: i64 = -3490578158;
pub const FDT_ASSUME_MASK: u32 = 0;
pub type u8_ = core::ffi::c_uchar;
pub type u16_ = core::ffi::c_ushort;
pub type u32_ = core::ffi::c_uint;
pub type u64_ = core::ffi::c_ulonglong;
pub type i8_ = core::ffi::c_schar;
pub type i16_ = core::ffi::c_short;
pub type i32_ = core::ffi::c_int;
pub type i64_ = core::ffi::c_longlong;
pub type uintptr = core::ffi::c_ulonglong;
pub type size = core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jerryMetaData {
    pub deviceTreeLen: u64_,
    pub ramStartAddr: *mut core::ffi::c_void,
    pub ramLen: u64_,
    pub kernelBinStartAddr: *mut core::ffi::c_void,
    pub kernelRodataStart: *mut core::ffi::c_void,
    pub kernelRodataEnd: *mut core::ffi::c_void,
    pub kernelTextStart: *mut core::ffi::c_void,
    pub kernelTextEnd: *mut core::ffi::c_void,
    pub kernelStackPointerStart: *mut core::ffi::c_void,
    pub kernelBssStart: *mut core::ffi::c_void,
    pub kernelBssEnd: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of jerryMetaData"][::core::mem::size_of::<jerryMetaData>() - 88usize];
    ["Alignment of jerryMetaData"][::core::mem::align_of::<jerryMetaData>() - 8usize];
    ["Offset of field: jerryMetaData::deviceTreeLen"]
        [::core::mem::offset_of!(jerryMetaData, deviceTreeLen) - 0usize];
    ["Offset of field: jerryMetaData::ramStartAddr"]
        [::core::mem::offset_of!(jerryMetaData, ramStartAddr) - 8usize];
    ["Offset of field: jerryMetaData::ramLen"]
        [::core::mem::offset_of!(jerryMetaData, ramLen) - 16usize];
    ["Offset of field: jerryMetaData::kernelBinStartAddr"]
        [::core::mem::offset_of!(jerryMetaData, kernelBinStartAddr) - 24usize];
    ["Offset of field: jerryMetaData::kernelRodataStart"]
        [::core::mem::offset_of!(jerryMetaData, kernelRodataStart) - 32usize];
    ["Offset of field: jerryMetaData::kernelRodataEnd"]
        [::core::mem::offset_of!(jerryMetaData, kernelRodataEnd) - 40usize];
    ["Offset of field: jerryMetaData::kernelTextStart"]
        [::core::mem::offset_of!(jerryMetaData, kernelTextStart) - 48usize];
    ["Offset of field: jerryMetaData::kernelTextEnd"]
        [::core::mem::offset_of!(jerryMetaData, kernelTextEnd) - 56usize];
    ["Offset of field: jerryMetaData::kernelStackPointerStart"]
        [::core::mem::offset_of!(jerryMetaData, kernelStackPointerStart) - 64usize];
    ["Offset of field: jerryMetaData::kernelBssStart"]
        [::core::mem::offset_of!(jerryMetaData, kernelBssStart) - 72usize];
    ["Offset of field: jerryMetaData::kernelBssEnd"]
        [::core::mem::offset_of!(jerryMetaData, kernelBssEnd) - 80usize];
};
unsafe extern "C" {
    pub fn strlen(s: *const core::ffi::c_char) -> size;
}
unsafe extern "C" {
    pub fn strchr(s: *const core::ffi::c_char, c: core::ffi::c_int) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncmp(s1: *const core::ffi::c_char, s2: *const core::ffi::c_char, n: size) -> i32_;
}
unsafe extern "C" {
    pub fn strStartsWith(input: *const core::ffi::c_char, prefix: *const core::ffi::c_char)
        -> bool;
}
unsafe extern "C" {
    pub fn memset(s: *mut core::ffi::c_void, c: u8_, n: size) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memchr(
        s: *const core::ffi::c_void,
        c: core::ffi::c_int,
        n: size,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(s1: *const core::ffi::c_void, s2: *const core::ffi::c_void, n: size) -> i32_;
}
pub type fdt16_t = u16_;
pub type fdt32_t = u32_;
pub type fdt64_t = u64_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdt_header {
    pub magic: fdt32_t,
    pub totalsize: fdt32_t,
    pub off_dt_struct: fdt32_t,
    pub off_dt_strings: fdt32_t,
    pub off_mem_rsvmap: fdt32_t,
    pub version: fdt32_t,
    pub last_comp_version: fdt32_t,
    pub boot_cpuid_phys: fdt32_t,
    pub size_dt_strings: fdt32_t,
    pub size_dt_struct: fdt32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_header"][::core::mem::size_of::<fdt_header>() - 40usize];
    ["Alignment of fdt_header"][::core::mem::align_of::<fdt_header>() - 4usize];
    ["Offset of field: fdt_header::magic"][::core::mem::offset_of!(fdt_header, magic) - 0usize];
    ["Offset of field: fdt_header::totalsize"]
        [::core::mem::offset_of!(fdt_header, totalsize) - 4usize];
    ["Offset of field: fdt_header::off_dt_struct"]
        [::core::mem::offset_of!(fdt_header, off_dt_struct) - 8usize];
    ["Offset of field: fdt_header::off_dt_strings"]
        [::core::mem::offset_of!(fdt_header, off_dt_strings) - 12usize];
    ["Offset of field: fdt_header::off_mem_rsvmap"]
        [::core::mem::offset_of!(fdt_header, off_mem_rsvmap) - 16usize];
    ["Offset of field: fdt_header::version"]
        [::core::mem::offset_of!(fdt_header, version) - 20usize];
    ["Offset of field: fdt_header::last_comp_version"]
        [::core::mem::offset_of!(fdt_header, last_comp_version) - 24usize];
    ["Offset of field: fdt_header::boot_cpuid_phys"]
        [::core::mem::offset_of!(fdt_header, boot_cpuid_phys) - 28usize];
    ["Offset of field: fdt_header::size_dt_strings"]
        [::core::mem::offset_of!(fdt_header, size_dt_strings) - 32usize];
    ["Offset of field: fdt_header::size_dt_struct"]
        [::core::mem::offset_of!(fdt_header, size_dt_struct) - 36usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdt_reserve_entry {
    pub address: fdt64_t,
    pub size: fdt64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_reserve_entry"][::core::mem::size_of::<fdt_reserve_entry>() - 16usize];
    ["Alignment of fdt_reserve_entry"][::core::mem::align_of::<fdt_reserve_entry>() - 8usize];
    ["Offset of field: fdt_reserve_entry::address"]
        [::core::mem::offset_of!(fdt_reserve_entry, address) - 0usize];
    ["Offset of field: fdt_reserve_entry::size"]
        [::core::mem::offset_of!(fdt_reserve_entry, size) - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct fdt_node_header {
    pub tag: fdt32_t,
    pub name: __IncompleteArrayField<core::ffi::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_node_header"][::core::mem::size_of::<fdt_node_header>() - 4usize];
    ["Alignment of fdt_node_header"][::core::mem::align_of::<fdt_node_header>() - 4usize];
    ["Offset of field: fdt_node_header::tag"]
        [::core::mem::offset_of!(fdt_node_header, tag) - 0usize];
    ["Offset of field: fdt_node_header::name"]
        [::core::mem::offset_of!(fdt_node_header, name) - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct fdt_property {
    pub tag: fdt32_t,
    pub len: fdt32_t,
    pub nameoff: fdt32_t,
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_property"][::core::mem::size_of::<fdt_property>() - 12usize];
    ["Alignment of fdt_property"][::core::mem::align_of::<fdt_property>() - 4usize];
    ["Offset of field: fdt_property::tag"][::core::mem::offset_of!(fdt_property, tag) - 0usize];
    ["Offset of field: fdt_property::len"][::core::mem::offset_of!(fdt_property, len) - 4usize];
    ["Offset of field: fdt_property::nameoff"]
        [::core::mem::offset_of!(fdt_property, nameoff) - 8usize];
    ["Offset of field: fdt_property::data"][::core::mem::offset_of!(fdt_property, data) - 12usize];
};
unsafe extern "C" {
    pub fn fdt_offset_ptr(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
        checklen: core::ffi::c_uint,
    ) -> *const core::ffi::c_void;
}
unsafe extern "C" {
    pub fn fdt_next_tag(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
        nextoffset: *mut core::ffi::c_int,
    ) -> u32_;
}
unsafe extern "C" {
    pub fn fdt_next_node(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
        depth: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_first_subnode() - get offset of first direct subnode\n @fdt:\tFDT blob\n @offset:\tOffset of node to check\n\n Return: offset of first subnode, or -FDT_ERR_NOTFOUND if there is none"]
    pub fn fdt_first_subnode(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_next_subnode() - get offset of next direct subnode\n @fdt:\tFDT blob\n @offset:\tOffset of previous subnode\n\n After first calling fdt_first_subnode(), call this function repeatedly to\n get direct subnodes of a parent node.\n\n Return: offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more\n         subnodes"]
    pub fn fdt_next_subnode(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_header_size - return the size of the tree's header\n @fdt: pointer to a flattened device tree\n\n Return: size of DTB header in bytes"]
    pub fn fdt_header_size(fdt: *const core::ffi::c_void) -> size;
}
unsafe extern "C" {
    #[doc = " fdt_header_size_ - internal function to get header size from a version number\n @version: device tree version number\n\n Return: size of DTB header in bytes"]
    pub fn fdt_header_size_(version: u32_) -> size;
}
unsafe extern "C" {
    #[doc = " fdt_check_header - sanity check a device tree header\n @fdt: pointer to data which might be a flattened device tree\n\n fdt_check_header() checks that the given buffer contains what\n appears to be a flattened device tree, and that the header contains\n valid information (to the extent that can be determined from the\n header alone).\n\n returns:\n     0, if the buffer appears to contain a valid device tree\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE,\n     -FDT_ERR_TRUNCATED, standard meanings, as above"]
    pub fn fdt_check_header(fdt: *const core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_move - move a device tree around in memory\n @fdt: pointer to the device tree to move\n @buf: pointer to memory where the device is to be moved\n @bufsize: size of the memory space at buf\n\n fdt_move() relocates, if possible, the device tree blob located at\n fdt to the buffer at buf of size bufsize.  The buffer may overlap\n with the existing device tree blob at fdt.  Therefore,\n     fdt_move(fdt, fdt, fdt_totalsize(fdt))\n should always succeed.\n\n returns:\n     0, on success\n     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_move(
        fdt: *const core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        bufsize: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_check_full(fdt: *const core::ffi::c_void, bufsize: size) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_string - retrieve a string from the strings block of a device tree\n @fdt: pointer to the device tree blob\n @stroffset: offset of the string within the strings block (native endian)\n @lenp: optional pointer to return the string's length\n\n fdt_get_string() retrieves a pointer to a single string from the\n strings block of the device tree blob at fdt, and optionally also\n returns the string's length in *lenp.\n\n returns:\n     a pointer to the string, on success\n     NULL, if stroffset is out of bounds, or doesn't point to a valid string"]
    pub fn fdt_get_string(
        fdt: *const core::ffi::c_void,
        stroffset: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_string - retrieve a string from the strings block of a device tree\n @fdt: pointer to the device tree blob\n @stroffset: offset of the string within the strings block (native endian)\n\n fdt_string() retrieves a pointer to a single string from the\n strings block of the device tree blob at fdt.\n\n returns:\n     a pointer to the string, on success\n     NULL, if stroffset is out of bounds, or doesn't point to a valid string"]
    pub fn fdt_string(
        fdt: *const core::ffi::c_void,
        stroffset: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_find_max_phandle - find and return the highest phandle in a tree\n @fdt: pointer to the device tree blob\n @phandle: return location for the highest phandle value found in the tree\n\n fdt_find_max_phandle() finds the highest phandle value in the given device\n tree. The value returned in @phandle is only valid if the function returns\n success.\n\n returns:\n     0 on success or a negative error code on failure"]
    pub fn fdt_find_max_phandle(
        fdt: *const core::ffi::c_void,
        phandle: *mut u32_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_generate_phandle - return a new, unused phandle for a device tree blob\n @fdt: pointer to the device tree blob\n @phandle: return location for the new phandle\n\n Walks the device tree blob and looks for the highest phandle value. On\n success, the new, unused phandle value (one higher than the previously\n highest phandle value in the device tree blob) will be returned in the\n @phandle parameter.\n\n Return: 0 on success or a negative error-code on failure"]
    pub fn fdt_generate_phandle(
        fdt: *const core::ffi::c_void,
        phandle: *mut u32_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_num_mem_rsv - retrieve the number of memory reserve map entries\n @fdt: pointer to the device tree blob\n\n Returns the number of entries in the device tree blob's memory\n reservation map.  This does not include the terminating 0,0 entry\n or any other (0,0) entries reserved for expansion.\n\n returns:\n     the number of entries"]
    pub fn fdt_num_mem_rsv(fdt: *const core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_mem_rsv - retrieve one memory reserve map entry\n @fdt: pointer to the device tree blob\n @n: index of reserve map entry\n @address: pointer to 64-bit variable to hold the start address\n @size: pointer to 64-bit variable to hold the size of the entry\n\n On success, @address and @size will contain the address and size of\n the n-th reserve map entry from the device tree blob, in\n native-endian format.\n\n returns:\n     0, on success\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_get_mem_rsv(
        fdt: *const core::ffi::c_void,
        n: core::ffi::c_int,
        address: *mut u64_,
        size: *mut u64_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_subnode_offset_namelen(
        fdt: *const core::ffi::c_void,
        parentoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_subnode_offset - find a subnode of a given node\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n\n fdt_subnode_offset() finds a subnode of the node at structure block\n offset parentoffset with the given name.  name may include a unit\n address, in which case fdt_subnode_offset() will find the subnode\n with that unit address, or the unit address may be omitted, in\n which case fdt_subnode_offset() will find an arbitrary subnode\n whose name excluding unit address matches the given name.\n\n returns:\n\tstructure block offset of the requested subnode (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested subnode does not exist\n\t-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE\n\t\ttag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_subnode_offset(
        fdt: *const core::ffi::c_void,
        parentoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_path_offset_namelen(
        fdt: *const core::ffi::c_void,
        path: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_path_offset - find a tree node by its full path\n @fdt: pointer to the device tree blob\n @path: full path of the node to locate\n\n fdt_path_offset() finds a node of a given path in the device tree.\n Each path component may omit the unit address portion, but the\n results of this are undefined if any such path component is\n ambiguous (that is if there are multiple nodes at the relevant\n level matching the given component, differentiated only by unit\n address).\n\n If the path is not absolute (i.e. does not begin with '/'), the\n first component is treated as an alias.  That is, the property by\n that name is looked up in the /aliases node, and the value of that\n property used in place of that first component.\n\n For example, for this small fragment\n\n / {\n     aliases {\n         i2c2 = &foo; // RHS compiles to \"/soc@0/i2c@30a40000/eeprom@52\"\n     };\n     soc@0 {\n         foo: i2c@30a40000 {\n             bar: eeprom@52 {\n             };\n         };\n     };\n };\n\n these would be equivalent:\n\n   /soc@0/i2c@30a40000/eeprom@52\n   i2c2/eeprom@52\n\n returns:\n\tstructure block offset of the node with the requested path (>=0), on\n\t\tsuccess\n\t-FDT_ERR_BADPATH, given path does not begin with '/' and the first\n\t\tcomponent is not a valid alias\n\t-FDT_ERR_NOTFOUND, if the requested node does not exist\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_path_offset(
        fdt: *const core::ffi::c_void,
        path: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_name - retrieve the name of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of the starting node\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_name() retrieves the name (including unit address) of the\n device tree node at structure block offset nodeoffset.  If lenp is\n non-NULL, the length of this name is also returned, in the integer\n pointed to by lenp.\n\n returns:\n\tpointer to the node's name, on success\n\t\tIf lenp is non-NULL, *lenp contains the length of that name\n\t\t\t(>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL *lenp contains an error code (<0):\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE\n\t\t\ttag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_get_name(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_first_property_offset - find the offset of a node's first property\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of a node\n\n fdt_first_property_offset() finds the first property of the node at\n the given structure block offset.\n\n returns:\n\tstructure block offset of the property (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested node has no properties\n\t-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_first_property_offset(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_next_property_offset - step through a node's properties\n @fdt: pointer to the device tree blob\n @offset: structure block offset of a property\n\n fdt_next_property_offset() finds the property immediately after the\n one at the given structure block offset.  This will be a property\n of the same node as the given property.\n\n returns:\n\tstructure block offset of the next property (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the given property is the last in its node\n\t-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_next_property_offset(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_property_by_offset - retrieve the property at a given offset\n @fdt: pointer to the device tree blob\n @offset: offset of the property to retrieve\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_property_by_offset() retrieves a pointer to the\n fdt_property structure within the device tree blob at the given\n offset.  If lenp is non-NULL, the length of the property value is\n also returned, in the integer pointed to by lenp.\n\n Note that this code only works on device tree versions >= 16. fdt_getprop()\n works on all versions.\n\n returns:\n\tpointer to the structure representing the property\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_get_property_by_offset(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    pub fn fdt_get_property_namelen(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    #[doc = " fdt_get_property - find a given property in a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_property() retrieves a pointer to the fdt_property\n structure within the device tree blob corresponding to the property\n named 'name' of the node at offset nodeoffset.  If lenp is\n non-NULL, the length of the property value is also returned, in the\n integer pointed to by lenp.\n\n returns:\n\tpointer to the structure representing the property\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_NOTFOUND, node does not have named property\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE\n\t\t\ttag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_get_property(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        lenp: *mut core::ffi::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    pub fn fdt_getprop_by_offset(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
        namep: *mut *const core::ffi::c_char,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_void;
}
unsafe extern "C" {
    pub fn fdt_getprop_namelen(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " fdt_getprop - retrieve the value of a given property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_getprop() retrieves a pointer to the value of the property\n named @name of the node at offset @nodeoffset (this will be a\n pointer to within the device blob itself, not a copy of the value).\n If @lenp is non-NULL, the length of the property value is also\n returned, in the integer pointed to by @lenp.\n\n returns:\n\tpointer to the property's value\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_NOTFOUND, node does not have named property\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE\n\t\t\ttag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_getprop(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " fdt_get_phandle - retrieve the phandle of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of the node\n\n fdt_get_phandle() retrieves the phandle of the device tree node at\n structure block offset nodeoffset.\n\n returns:\n\tthe phandle of the node at nodeoffset, on success (!= 0, != -1)\n\t0, if the node has no phandle, or another error occurs"]
    pub fn fdt_get_phandle(fdt: *const core::ffi::c_void, nodeoffset: core::ffi::c_int) -> u32_;
}
unsafe extern "C" {
    pub fn fdt_get_alias_namelen(
        fdt: *const core::ffi::c_void,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_get_alias - retrieve the path referenced by a given alias\n @fdt: pointer to the device tree blob\n @name: name of the alias to look up\n\n fdt_get_alias() retrieves the value of a given alias.  That is, the\n value of the property named @name in the node /aliases.\n\n returns:\n\ta pointer to the expansion of the alias named 'name', if it exists\n\tNULL, if the given alias or the /aliases node does not exist"]
    pub fn fdt_get_alias(
        fdt: *const core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fdt_get_symbol_namelen(
        fdt: *const core::ffi::c_void,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_get_symbol - retrieve the path referenced by a given symbol\n @fdt: pointer to the device tree blob\n @name: name of the symbol to look up\n\n fdt_get_symbol() retrieves the value of a given symbol.  That is,\n the value of the property named @name in the node\n /__symbols__. Such a node exists only for a device tree blob that\n has been compiled with the -@ dtc option. Each property corresponds\n to a label appearing in the device tree source, with the name of\n the property being the label and the value being the full path of\n the node it is attached to.\n\n returns:\n\ta pointer to the expansion of the symbol named 'name', if it exists\n\tNULL, if the given symbol or the /__symbols__ node does not exist"]
    pub fn fdt_get_symbol(
        fdt: *const core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_get_path - determine the full path of a node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose path to find\n @buf: character buffer to contain the returned path (will be overwritten)\n @buflen: size of the character buffer at buf\n\n fdt_get_path() computes the full path of the node at offset\n nodeoffset, and records that path in the buffer at buf.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\t0, on success\n\t\tbuf contains the absolute path of the node at\n\t\tnodeoffset, as a NUL-terminated string.\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)\n\t\tcharacters and will not fit in the given buffer.\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_get_path(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        buf: *mut core::ffi::c_char,
        buflen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_supernode_atdepth_offset - find a specific ancestor of a node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n @supernodedepth: depth of the ancestor to find\n @nodedepth: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_supernode_atdepth_offset() finds an ancestor of the given node\n at a specific depth from the root (where the root itself has depth\n 0, its immediate subnodes depth 1 and so forth).  So\n\tfdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);\n will always return 0, the offset of the root node.  If the node at\n nodeoffset has depth D, then:\n\tfdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);\n will return nodeoffset itself.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\tstructure block offset of the node at node offset's ancestor\n\t\tof depth supernodedepth (>=0), on success\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of\n\t\tnodeoffset\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_supernode_atdepth_offset(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        supernodedepth: core::ffi::c_int,
        nodedepth: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_depth - find the depth of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n\n fdt_node_depth() finds the depth of a given node.  The root node\n has depth 0, its immediate subnodes depth 1 and so forth.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\tdepth of the node at nodeoffset (>=0), on success\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_depth(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_parent_offset - find the parent of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n\n fdt_parent_offset() locates the parent node of a given node (that\n is, it finds the offset of the node which contains the node at\n nodeoffset as a subnode).\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset, *twice*.\n\n returns:\n\tstructure block offset of the parent of the node at nodeoffset\n\t\t(>=0), on success\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_parent_offset(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_prop_value - find nodes with a given property value\n @fdt: pointer to the device tree blob\n @startoffset: only find nodes after this offset\n @propname: property name to check\n @propval: property value to search for\n @proplen: length of the value in propval\n\n fdt_node_offset_by_prop_value() returns the offset of the first\n node after startoffset, which has a property named propname whose\n value is of length proplen and has value equal to propval; or if\n startoffset is -1, the very first such node in the tree.\n\n To iterate through all nodes matching the criterion, the following\n idiom can be used:\n\toffset = fdt_node_offset_by_prop_value(fdt, -1, propname,\n\t\t\t\t\t       propval, proplen);\n\twhile (offset != -FDT_ERR_NOTFOUND) {\n\t\t// other code here\n\t\toffset = fdt_node_offset_by_prop_value(fdt, offset, propname,\n\t\t\t\t\t\t       propval, proplen);\n\t}\n\n Note the -1 in the first call to the function, if 0 is used here\n instead, the function will never locate the root node, even if it\n matches the criterion.\n\n returns:\n\tstructure block offset of the located node (>= 0, >startoffset),\n\t\t on success\n\t-FDT_ERR_NOTFOUND, no node matching the criterion exists in the\n\t\ttree after startoffset\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_prop_value(
        fdt: *const core::ffi::c_void,
        startoffset: core::ffi::c_int,
        propname: *const core::ffi::c_char,
        propval: *const core::ffi::c_void,
        proplen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_phandle - find the node with a given phandle\n @fdt: pointer to the device tree blob\n @phandle: phandle value\n\n fdt_node_offset_by_phandle() returns the offset of the node\n which has the given phandle value.  If there is more than one node\n in the tree with the given phandle (an invalid tree), results are\n undefined.\n\n returns:\n\tstructure block offset of the located node (>= 0), on success\n\t-FDT_ERR_NOTFOUND, no node with that phandle exists\n\t-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_phandle(
        fdt: *const core::ffi::c_void,
        phandle: u32_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_check_compatible - check a node's compatible property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of a tree node\n @compatible: string to match against\n\n fdt_node_check_compatible() returns 0 if the given node contains a\n @compatible property with the given string as one of its elements,\n it returns non-zero otherwise, or on error.\n\n returns:\n\t0, if the node has a 'compatible' property listing the given string\n\t1, if the node has a 'compatible' property, but it does not list\n\t\tthe given string\n\t-FDT_ERR_NOTFOUND, if the given node has no 'compatible' property\n\t-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_check_compatible(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        compatible: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_compatible - find nodes with a given 'compatible' value\n @fdt: pointer to the device tree blob\n @startoffset: only find nodes after this offset\n @compatible: 'compatible' string to match against\n\n fdt_node_offset_by_compatible() returns the offset of the first\n node after startoffset, which has a 'compatible' property which\n lists the given compatible string; or if startoffset is -1, the\n very first such node in the tree.\n\n To iterate through all nodes matching the criterion, the following\n idiom can be used:\n\toffset = fdt_node_offset_by_compatible(fdt, -1, compatible);\n\twhile (offset != -FDT_ERR_NOTFOUND) {\n\t\t// other code here\n\t\toffset = fdt_node_offset_by_compatible(fdt, offset, compatible);\n\t}\n\n Note the -1 in the first call to the function, if 0 is used here\n instead, the function will never locate the root node, even if it\n matches the criterion.\n\n returns:\n\tstructure block offset of the located node (>= 0, >startoffset),\n\t\t on success\n\t-FDT_ERR_NOTFOUND, no node matching the criterion exists in the\n\t\ttree after startoffset\n\t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_compatible(
        fdt: *const core::ffi::c_void,
        startoffset: core::ffi::c_int,
        compatible: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_stringlist_contains - check a string list property for a string\n @strlist: Property containing a list of strings to check\n @listlen: Length of property\n @str: String to search for\n\n This is a utility function provided for convenience. The list contains\n one or more strings, each terminated by \\0, as is found in a device tree\n \"compatible\" property.\n\n Return: 1 if the string is found in the list, 0 not found, or invalid list"]
    pub fn fdt_stringlist_contains(
        strlist: *const core::ffi::c_char,
        listlen: core::ffi::c_int,
        str_: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_stringlist_count - count the number of strings in a string list\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of a tree node\n @property: name of the property containing the string list\n\n Return:\n   the number of strings in the given property\n   -FDT_ERR_BADVALUE if the property value is not NUL-terminated\n   -FDT_ERR_NOTFOUND if the property does not exist"]
    pub fn fdt_stringlist_count(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        property: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_stringlist_search - find a string in a string list and return its index\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of a tree node\n @property: name of the property containing the string list\n @string: string to look up in the string list\n\n Note that it is possible for this function to succeed on property values\n that are not NUL-terminated. That's because the function will stop after\n finding the first occurrence of @string. This can for example happen with\n small-valued cell properties, such as #address-cells, when searching for\n the empty string.\n\n return:\n   the index of the string in the list of strings\n   -FDT_ERR_BADVALUE if the property value is not NUL-terminated\n   -FDT_ERR_NOTFOUND if the property does not exist or does not contain\n                     the given string"]
    pub fn fdt_stringlist_search(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        property: *const core::ffi::c_char,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_stringlist_get() - obtain the string at a given index in a string list\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of a tree node\n @property: name of the property containing the string list\n @index: index of the string to return\n @lenp: return location for the string length or an error code on failure\n\n Note that this will successfully extract strings from properties with\n non-NUL-terminated values. For example on small-valued cell properties\n this function will return the empty string.\n\n If non-NULL, the length of the string (on success) or a negative error-code\n (on failure) will be stored in the integer pointer to by lenp.\n\n Return:\n   A pointer to the string at the given index in the string list or NULL on\n   failure. On success the length of the string will be stored in the memory\n   location pointed to by the lenp parameter, if non-NULL. On failure one of\n   the following negative error codes will be returned in the lenp parameter\n   (if non-NULL):\n     -FDT_ERR_BADVALUE if the property value is not NUL-terminated\n     -FDT_ERR_NOTFOUND if the property does not exist"]
    pub fn fdt_stringlist_get(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        property: *const core::ffi::c_char,
        index: core::ffi::c_int,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_address_cells - retrieve address size for a bus represented in the tree\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to find the address size for\n\n When the node has a valid #address-cells property, returns its value.\n\n returns:\n\t0 <= n < FDT_MAX_NCELLS, on success\n\t2, if the node has no #address-cells property\n\t-FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid\n\t\t#address-cells property\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_address_cells(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_size_cells - retrieve address range size for a bus represented in the\n                  tree\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to find the address range size for\n\n When the node has a valid #size-cells property, returns its value.\n\n returns:\n\t0 <= n < FDT_MAX_NCELLS, on success\n\t1, if the node has no #size-cells property\n\t-FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid\n\t\t#size-cells property\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_size_cells(
        fdt: *const core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_setprop_inplace_namelen_partial(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
        idx: u32_,
        val: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_setprop_inplace(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        val: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_nop_property - replace a property with nop tags\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to nop\n @name: name of the property to nop\n\n fdt_nop_property() will replace a given property's representation\n in the blob with FDT_NOP tags, effectively removing it from the\n tree.\n\n This function will alter only the bytes in the blob which contain\n the property, and will not alter or move any other part of the\n tree.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, node does not have the named property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_nop_property(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_nop_node - replace a node (subtree) with nop tags\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to nop\n\n fdt_nop_node() will replace a given node's representation in the\n blob, including all its subnodes, if any, with FDT_NOP tags,\n effectively removing it from the tree.\n\n This function will alter only the bytes in the blob which contain\n the node and its properties and subnodes, and will not alter or\n move any other part of the tree.\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_nop_node(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_create_with_flags - begin creation of a new fdt\n @buf: pointer to memory allocated where fdt will be created\n @bufsize: size of the memory space at fdt\n @flags: a valid combination of FDT_CREATE_FLAG_ flags, or 0.\n\n fdt_create_with_flags() begins the process of creating a new fdt with\n the sequential write interface.\n\n fdt creation process must end with fdt_finish() to produce a valid fdt.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, bufsize is insufficient for a minimal fdt\n\t-FDT_ERR_BADFLAGS, flags is not valid"]
    pub fn fdt_create_with_flags(
        buf: *mut core::ffi::c_void,
        bufsize: core::ffi::c_int,
        flags: u32_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_create - begin creation of a new fdt\n @buf: pointer to memory allocated where fdt will be created\n @bufsize: size of the memory space at fdt\n\n fdt_create() is equivalent to fdt_create_with_flags() with flags=0.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, bufsize is insufficient for a minimal fdt"]
    pub fn fdt_create(buf: *mut core::ffi::c_void, bufsize: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_resize(
        fdt: *mut core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        bufsize: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_add_reservemap_entry(
        fdt: *mut core::ffi::c_void,
        addr: u64_,
        size: u64_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_finish_reservemap(fdt: *mut core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_begin_node(
        fdt: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_property(
        fdt: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        val: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_property_placeholder - add a new property and return a ptr to its value\n\n @fdt: pointer to the device tree blob\n @name: name of property to add\n @len: length of property value in bytes\n @valp: returns a pointer to where where the value should be placed\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_NOSPACE, standard meanings"]
    pub fn fdt_property_placeholder(
        fdt: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        len: core::ffi::c_int,
        valp: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_end_node(fdt: *mut core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_finish(fdt: *mut core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_create_empty_tree(
        buf: *mut core::ffi::c_void,
        bufsize: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_open_into(
        fdt: *const core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        bufsize: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_pack(fdt: *mut core::ffi::c_void) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_add_mem_rsv - add one memory reserve map entry\n @fdt: pointer to the device tree blob\n @address: 64-bit start address of the reserve map entry\n @size: 64-bit size of the reserved region\n\n Adds a reserve map entry to the given blob reserving a region at\n address address of length size.\n\n This function will insert data into the reserve map and will\n therefore change the indexes of some entries in the table.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new reservation entry\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_add_mem_rsv(
        fdt: *mut core::ffi::c_void,
        address: u64_,
        size: u64_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_del_mem_rsv - remove a memory reserve map entry\n @fdt: pointer to the device tree blob\n @n: entry to remove\n\n fdt_del_mem_rsv() removes the n-th memory reserve map entry from\n the blob.\n\n This function will delete data from the reservation table and will\n therefore change the indexes of some entries in the table.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there\n\t\tare less than n+1 reserve map entries)\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_del_mem_rsv(fdt: *mut core::ffi::c_void, n: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_set_name - change the name of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of a node\n @name: name to give the node\n\n fdt_set_name() replaces the name (including unit address, if any)\n of the given node with the given string.  NOTE: this function can't\n efficiently check if the new name is unique amongst the given\n node's siblings; results are undefined if this function is invoked\n with a name equal to one of the given node's siblings.\n\n This function may insert or delete data from the blob, and will\n therefore change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob\n\t\tto contain the new name\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_set_name(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_setprop_namelen - create or change a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to change\n @name: name of the property to change\n @namelen: length of the name\n @val: pointer to data to set the property value to\n @len: length of the property value\n\n fdt_setprop_namelen() sets the value of the named property in the given\n node to the given value and length, creating the property if it\n does not already exist.\n\n This function may insert or delete data from the blob, and will\n therefore change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new property value\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_setprop_namelen(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
        val: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_setprop_placeholder_namelen - allocate space for a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to change\n @name: name of the property to change\n @namelen: length of the name\n @len: length of the property value\n @prop_data: return pointer to property data\n\n fdt_setprop_placeholder_namelen() allocates the named property in the given node.\n If the property exists it is resized. In either case a pointer to the\n property data is returned.\n\n This function may insert or delete data from the blob, and will\n therefore change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new property value\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_setprop_placeholder_namelen(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
        len: core::ffi::c_int,
        prop_data: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_appendprop - append to or create a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to change\n @name: name of the property to append to\n @val: pointer to data to append to the property value\n @len: length of the data to append to the property value\n\n fdt_appendprop() appends the value to the named property in the\n given node, creating the property if it does not already exist.\n\n This function may insert data into the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new property value\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_appendprop(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        val: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_appendprop_addrrange - append a address range property\n @fdt: pointer to the device tree blob\n @parent: offset of the parent node\n @nodeoffset: offset of the node to add a property at\n @name: name of property\n @addr: start address of a given range\n @size: size of a given range\n\n fdt_appendprop_addrrange() appends an address range value (start\n address and size) to the value of the named property in the given\n node, or creates a new property with that value if it does not\n already exist.\n\n Cell sizes are determined by parent's #address-cells and #size-cells.\n\n This function may insert data into the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid\n\t\t#address-cells property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADVALUE, addr or size doesn't fit to respective cells size\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain a new property\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_appendprop_addrrange(
        fdt: *mut core::ffi::c_void,
        parent: core::ffi::c_int,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        addr: u64_,
        size: u64_,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_delprop - delete a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to nop\n @name: name of the property to nop\n\n fdt_delprop() will delete the given property.\n\n This function will delete data from the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, node does not have the named property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_delprop(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_add_subnode_namelen(
        fdt: *mut core::ffi::c_void,
        parentoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
        namelen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_add_subnode - creates a new node\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n\n fdt_add_subnode() creates a new node as a subnode of the node at\n structure block offset parentoffset, with the given name (which\n should include the unit address, if any).\n\n This function will insert data into the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\tstructure block offset of the created subnode (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested subnode does not exist\n\t-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE\n\t\ttag\n\t-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of\n\t\tthe given name\n\t-FDT_ERR_NOSPACE, if there is insufficient free space in the\n\t\tblob to contain the new node\n\t-FDT_ERR_NOSPACE\n\t-FDT_ERR_BADLAYOUT\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_add_subnode(
        fdt: *mut core::ffi::c_void,
        parentoffset: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_del_node - delete a node (subtree)\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to nop\n\n fdt_del_node() will remove the given node, including all its\n subnodes if any, from the blob.\n\n This function will delete data from the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_del_node(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_overlay_apply - Applies a DT overlay on a base DT\n @fdt: pointer to the base device tree blob\n @fdto: pointer to the device tree overlay blob\n\n fdt_overlay_apply() will apply the given device tree overlay on the\n given base device tree.\n\n Expect the base device tree to be modified, even if the function\n returns an error.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there's not enough space in the base device tree\n\t-FDT_ERR_NOTFOUND, the overlay points to some nonexistent nodes or\n\t\tproperties in the base DT\n\t-FDT_ERR_BADPHANDLE,\n\t-FDT_ERR_BADOVERLAY,\n\t-FDT_ERR_NOPHANDLES,\n\t-FDT_ERR_INTERNAL,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADOFFSET,\n\t-FDT_ERR_BADPATH,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_overlay_apply(
        fdt: *mut core::ffi::c_void,
        fdto: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_overlay_target_offset - retrieves the offset of a fragment's target\n @fdt: Base device tree blob\n @fdto: Device tree overlay blob\n @fragment_offset: node offset of the fragment in the overlay\n @pathp: pointer which receives the path of the target (or NULL)\n\n fdt_overlay_target_offset() retrieves the target offset in the base\n device tree of a fragment, no matter how the actual targeting is\n done (through a phandle or a path)\n\n returns:\n      the targeted node offset in the base device tree\n      Negative error code on error"]
    pub fn fdt_overlay_target_offset(
        fdt: *const core::ffi::c_void,
        fdto: *const core::ffi::c_void,
        fragment_offset: core::ffi::c_int,
        pathp: *mut *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_strerror(errval: core::ffi::c_int) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fdt_ro_probe_(fdt: *const core::ffi::c_void) -> i32_;
}
unsafe extern "C" {
    pub fn fdt_check_node_offset_(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_check_prop_offset_(
        fdt: *const core::ffi::c_void,
        offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fdt_find_string_len_(
        strtab: *const core::ffi::c_char,
        tabsize: core::ffi::c_int,
        s: *const core::ffi::c_char,
        s_len: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fdt_node_end_offset_(
        fdt: *mut core::ffi::c_void,
        nodeoffset: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub const ASSUME_PERFECT: _bindgen_ty_1 = 255;
pub const ASSUME_VALID_DTB: _bindgen_ty_1 = 1;
pub const ASSUME_VALID_INPUT: _bindgen_ty_1 = 2;
pub const ASSUME_LATEST: _bindgen_ty_1 = 4;
pub const ASSUME_NO_ROLLBACK: _bindgen_ty_1 = 8;
pub const ASSUME_LIBFDT_ORDER: _bindgen_ty_1 = 16;
pub const ASSUME_LIBFDT_FLAWLESS: _bindgen_ty_1 = 32;
pub type _bindgen_ty_1 = core::ffi::c_uint;
